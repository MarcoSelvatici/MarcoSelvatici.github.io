<head lang="en">
    <title>WASM Tutorial</title>
    <meta charset="utf-8">
    <link rel="shortcut icon" href="ref/wasm.png">
	<meta name="author" content="Marco Selvatici">
	<meta name="description" content="Webassembly tutorial: from begginers to advanced concepts through examples.">

    <meta property="og:image" content="ref/wasm.png">
    <meta property="og:title" content="Webassembly tutorial">
	<meta property="og:description" content="Webassembly tutorial: from begginers to advanced concepts through examples.">

    <link href="prism.css" rel="stylesheet" />
    <style>
    body{
        background-color: rgb(189, 188, 188);
        margin-top: 0px;
        font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif;
        font-size: 1.2em;
        line-height: 1.55em;
    }
    
    #bodyWrapper{
        margin: auto; 
        width: 1000px;
        padding: 30px;
        background-color: white;
    }

    #top{
        height: 330px;
    }

    #titleImg{
        float: left;
    }

    #mainTitleWrapper{
        width: 300;
        margin-right: 350px;
        float: right;
        line-height: 70px;
        font-size: 40px;
    }

    #indexPart{
        height: 445px;
    }

    #table_of_contents{
        float: left;
    }

    #rightColumn{
        float: right;
        position: relative;
        height: 445px;
        width: 400px;
    }

    #author{
        position: absolute;
        bottom: 10;
        right: 0;
    }

    .important{
        background-color: rgb(253, 253, 158);
        padding: 4px 10px;
        margin: 5px 0px;
    }

    .inline{
        background-color: rgb(233, 233, 233);
        padding: 2px 4px;
        border-radius: 2px;
    }

    .italic{
        font-style: italic;
    }

    hr{
        border-top: 3px solid black;
        border-bottom: 0px;         
    }

    h1{
        margin-top: 160px;
        margin-bottom: 0px;
    }

    h2{
        /*margin: 40px auto 10px auto;*/
        margin: 30px 0px;
    }

    .center{
        display: block;
        margin: 20px auto;
        border: 1px solid grey;
        box-shadow: 4px 4px 3px grey;
    }

    ul, ol{
        margin: 0px auto;
    }
    </style>
</head>
<body>
    <div id="bodyWrapper">
        <div id="top">
            <img id="titleImg" src="ref/wasm.png" width="30%"/>
            <div id="mainTitleWrapper">
                <h1>Webassembly Tutorial</h1>
            </div>
        </div>
        <hr>
        <div id="indexPart">
            <div id="table_of_contents">
                <h2 style="margin-top: 17px; margin-bottom: 10px;">Table of contents</h2>
                <ol style="font-size: 0.9em; margin-left:0px;">
                    <a href="#introduction"><li>Introduction</li></a>
                    <a href="#key_concepts"><li>Key concepts</li></a>
                    <a href="#WASM_workflow"><li>WASM workflow</li></a>
                    <a href="#browser_environment"><li>Browser environment</li></a>
                    <a href="#install_emscripten"><li>Install Emscripten</li></a>
                    <a href="#your_first_WASM_WebApp"><li>Your first WASM WebApp</li></a>
                    <a href="#functions"><li>Functions</li></a>
                    <a href="#call_javascript_from_C/C++"><li>Call JavaScript from C/C++</li></a>
                    <a href="#libraries"><li>Libraries</li></a>
                    <a href="#memory"><li>Memory</li></a>
                    <a href="#conclusion"><li>Conclusion</li></a>
                    <a href="#references"><li>References</li></a>
                    <a href="#comments"><li>Comments</li></a>
                </ol>
            </div>
            <div id="rightColumn">
                <div id="author">
                    by <a href="http://marcoselvatici.github.io">Marco Selvatici</a>
                </div>
            </div>
        </div>
        <hr>
        <!-- ==================================== INTRODUCTION ==================================== -->
        <h2 id="introduction">Introduction</h2>
        Webassembly (WASM) is an innovative low-level language that can run on all modern browsers. As the name suggests, this is an assembly-like language that have a very compact binary format (thus suitable to be loaded on web pages) and can run with near-native performance.<br>
        Thanks to this technology, there is now the possibility to compile high-level languages and run them on the browser achieving high performance. Currently the only languages that can be compiled to WASM binaries are C and C++, but in future the list will probably grow a lot.<br>
        <br>
        It is important to point out that WASM is not going to cut off JavaScript, you will still need it for several reasons that will be explained in this tutorial.<br>
        <br>
        In this tutorial, you will learn the basics concepts behind this technology and you will be then ready to create your incredible Webassembly-based webapp!<br>
        Furthermore, I am going to guide you through this concepts by using examples and also presenting the online file compressor I created using a C library on the browser (you can find it here!).<br>
        <br>
        So... Let's get started!

        <!-- ==================================== KEY CONCEPTS ==================================== -->
        <h2 id="key_concepts">Key concepts</h2>
        There are a few key concepts that we need to know about WASM:
        <ul>
            <li><span class="italic">Module</span>: it is the compiled binary source (in other words, the .wasm file).</li>
            <li><span class="italic">Memory</span>: a JavaScript typed array that represents the memory for your program.</li>
            <li><span class="italic">Table</span>: an array (separated from the memory) that contains the references to the function that you use.</li>
            <li><span class="italic">Instance</span>: it is the union of a Module, a Memory and a Table plus some other values that needs to be stored.</li>
        </ul>
        Don't worry if you don't get everything at this stage, things will start to make sense once you see them working.

        <!-- ==================================== WASM WORKFLOW ==================================== -->
        <h2 id="WASM_workflow">WASM workflow</h2>
        If you are familiar with compiled languages, you probably know the steps that your code go through before being executed. Just as a reminder:<br>
        <img class="center" src="ref/compile.gif"/>
        If you worked with C/C++, you probably used compilers like gcc or similar. In order to get a Webassembly binary file, we will need some other special compilers. There are more than one available, but currently the best one is Emscripten.<br>
        Differently from the "normal" assembly languages, Webassembly is not CPU specific and therefore can run on multiple platforms, from embedded systems like your phone to the CPU of your computer.<br>
        <br>
        Once we compile our C/C++ code with Emscripten, we obtain a proper WASM file that can run on the browser, pretty straightforward right?<br>
        Actually, there are a few more details to consider, but we will cover them step by step.<br>
        <br>
        Briefly, the steps to get your WASM WebApp working are:
        <ol>
            <li>Compile C/C++ code with Emscripten, to obtain a WASM binary.</li>
            <li>Bind your WASM binary to your page using a JavaScript "glue code".</li>
            <li>Run your app and let the browser to instantiate your WASM module, the memory and the table of references. Once that is done, your WebApp is fully operative.</li>
        </ol>

        <!-- ==================================== BROWSER ENVIRONMENT ==================================== -->
        <h2 id="browser_environment">Browser environment</h2>
        It is really important to understand that WASM binaries are run in the same sandbox as JavaScript (in a nutshell, a sandbox is an isolated environment where your code is executed for security reasons).<br>
        <img class="center" src="ref/sandbox.gif" />
        Therefore, you will be able to access only the data that are also accessible with JavaScript. This means, for example, that you will not be able to access a file like this:<br>

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-css">FILE *fp;
fp=fopen("/path/to/file/test.txt", "r");</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        Instead, you will have to read them via JavaScript and then use them with WASM, but we will return on this later.<br>
        You will furthermore have some limitations in the memory you can dynamically and statically allocate, depending on the browser you are using (but these are usually pretty big, so it is unlikely that you will suffer from that).

        <!-- ==================================== INSTALL EMSCRIPTEN ==================================== -->
        <h2 id="install_emscripten">Install Emscripten</h2>
        
        First of all, let's install the WASM compiler, Emscripten.
        We will focus on how to install it for Linux, but you can find documentation for other OS <a target="_blank" href="https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html">here</a>.<br>
        <br>
        First of all you need to have installed a working compiler toolchain (the set of tools that allows you to compile the code and get an executable) since we will build the software from the source code. Open a terminal and type:<br>

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash"># Update the package lists
sudo apt-get update

# Install *gcc* (and related dependencies)
sudo apt-get install build-essential

# Install cmake
sudo apt-get install cmake</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        You also need to install:
        <ul>
            <li>python 2.7</li>
            <li>node.js</li>
        </ul>

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash"># Install Python
sudo apt-get install python2.7

# Install node.js
sudo apt-get install nodejs</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        Great! Now we have all the prerequisites to install the Emscripten Software Development Kit (emsdk). Just follow these steps:
        <ol>
            <li>Download and unzip the Software Development Kit (SDK) package to the directory of your choice. Here is the the <a target="_blank" href="https://s3.amazonaws.com/mozilla-games/emscripten/releases/emsdk-portable.tar.gz">link</a>.</li>
            <li>Open a terminal inside the folder <code class="inline">emsdk-portable</code> you already unzipped and run the emsdk commands to obtain the latest tools from Github and set them as active:<br>

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash"># Fetch the latest registry of available tools.
./emsdk update

# Download and install the latest SDK tools. This may take a while
./emsdk install latest

# Make the "latest" SDK "active" for the current user. (writes ~/.emscripten file)
./emsdk activate latest

# Activate PATH and other environment variables in the current terminal
source ./emsdk_env.sh</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

            At this point, you should see something like that.
            <img class="center" src="ref/activate.png" width="80%"/>
            </li>
        </ol>

        <!-- ==================================== YOUR FIRST WASM WEBAPP ==================================== -->
        <h2 id="your_first_WASM_WebApp">Your first WASM webapp</h2>
        Once Emscripten is installed, we are ready to create our first WASM app!
       
        <ol>
            <li>Create a folder wherever you want that contains a C file with this simple code:</li>

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-c">#include &lt;stdio.h>

int main(){
    printf("hello world!\n");
    return 0;
}</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

            <li>With your previous terminal, move in to the new directory and compile the C code to WASM using emscripten.<br>

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash">emcc hello.c -o hello.html -s WASM=1</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->
                    
                <div class="important">
                    IMPORTANT:<br>
                    when you open a new terminal you won't be able to run the emcc command. You will indeed obtain this error:<br>

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-none">The program 'emcc' is currently not installed. You can install it by typing:
sudo apt install emscripten.</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

                    DON'T DO IT, the version that will be installed is outdated or broken and will give you tons of issues. Instead, just move back to the <code>emsdk-portable</code> directory and type:<br>

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash">source ./emsdk_env.sh</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

                to activate the path and other environmental variables to this current terminal.<br>
                Then move again to the repository with the file to compile and go on with the compilation.
            </div>

            Explanation:<br>
            <code class="inline">emcc</code> is program you call to compile your C code (similar to call gcc or g++ when you compile your C/C++ files).
            <ul>
                <li><code class="inline">-o hello.html</code> tells the compiler to create hello.html so you can visualize the results of the WASM code.</li>
                <li><code class="inline">-s WASM=1</code> tells the compiler to create a separated .wasm file. You can omit this and the everything will work the same, just your hello.js (see next point) will contain also the wasm binary.</li>
            </ul>
                Note that since this is the first time you use the stdio.h library, it needs to compile it to WASM binary before it can actually compile your code. This may take some moments.
            </li><br>
            <li>
                Now you should be able to see other three files in the same directory: <code class="inline">hello.html</code>, <code class="inline">hello.js</code> and <code class="inline">hello.wasm</code>.
                <ul>
                    <li><code class="inline">hello.wasm</code> is the file that contains the Webassembly code (the compiled code).</li>
                    <li><code class="inline">hello.js</code> is the "glue code" needed to allow JavaScript to call and "communicate" with WASM compiled code. Emscripten generates this automatically and it is absolutely needed in order to run WASM modules. If you compile without the <code class="inline">-s WASM=1</code> flag this file will contain also the content of hello.wasm (but makes no difference in reality).</li>
                    <li><code class="inline">hello.html</code> is just a web page automatically generated that shows the result of your Webassembly code in a user friendly way. You don't actually need this file, but it is a cool way to quickly visualize what are you doing. You can tell Emscripten to not generate it by just doing <code class="inline">-o hello.js</code> instead of <code class="inline">-o hello.html</code> (everything else stays as before).</li>
                </ul>
            </li>
        </ol>
        <br>
        If you haven't tried to open the file hello.html file yet, do it with the browser of your choice. You should see something like this:<br>
        <img class="center" src="ref/helloworld.png" width="100%"/>
        If you open it with certain browsers (like Chrome) you may get an error message instead of the words "Hello World!".<br>
        That is because the operation of loading of the WASM module is asynchronous, and some browsers (for security reasons) do not allow you to do this if the url is of the kind <code class="inline">file://path/to/file/file.html</code>.<br>
        In order to solve that issue you can both change the browser you use for testing (Firefox will work) or run a local server this way:
        <ol>
            <li>open a terminal in the directory containing the file .html you want to run, and control your python version by typing:<br>

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash">python -V</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->
                
            </li>
            <li>and then run:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash"># if your version is 2.x
python -m SimpleHTTPServer 8080

# if your version is 3.x
python -m http.server 8080
</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

            </li>
            <li>
            At this point go in the browser and open (type in the URL) <code class="inline">localhost:8080</code>. Note that the number 8080 is the same as the one you typed in the terminal previously (you can change it if you want, but be careful since not all the ports are for http).
            </li>
        </ol>

        <br>
        Let's return talking about WASM.<br>
        The first thing that WASM does is execute the main of your code (if there is one). That is why you immediately see "Hello world!" printed in that pseudo-console.<br>
        Note that you don't actually need that pretty interface: try to open the console (press <code class="inline">F12</code> or <code class="inline">Ctrl+Shift+C</code>). You should be able to see the words "Hello World!" printed there as well. Indeed, all your prints are printed in that console, and you can use them to debug your C/C++ code.<br>
        <br>
        You can now try to create your own web page and run your short WASM-compiled code on that. Create a file .html and copy this simple code:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-html">&lt;script src="hello.js">&lt;/script>
&lt;p>Open the console to see the result!&lt;/p>
</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        and open it in the browser.<br>
        You may see these warnings:
        <img class="center" src="ref/warning.png" />
        Just don't worry about them, we are not using that method to create our WASM instance.<br>
        <br>
        <div class="important">
            IMPORTANT:<br>
            everything we did in this section is perfectly transferable on a C++ code. Try changing hello.c to hello.cpp:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-c">#include &lt;iostream>

int main(){
    std::cout << "Hello world!" << std::endl;
    return 0;
}
</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

            and compile it with:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash"># note that also emcc will work as well
em++ hello.cpp -o hello.html
</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        </div><br>
        <div class="important">
            IMPORTANT:<br>
            You can also compile your code using optimizations using <code class="inline">-Ox</code>, try them out:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash"># -O2 is already a pretty high level of optimization
emcc hello.c -o hello.js -O2 -s WASM=1
</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->
        
        </div>

        <!-- ==================================== FUNCTIONS ==================================== -->
        <h2 id="functions">Functions</h2>
        So far we learnt how to build a simple WASM project. Let's make things more interesting by introducing functions.<br>
        Edit the <code class="inline">hello.c</code> code by adding a function to calculate the i<sup>th</sup> number in the Fibonacci sequence:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-c">#include &lt;stdio.h>
int fib(int n){
    if(n == 0 || n == 1)
        return 1;
    else
        return fib(n-1)+fib(n-2);
}

int main(){
    printf("Hello world!\n");
    int res = fib(5);
    printf("fib(5) = %d\n", res);
    return 0;
}</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->
            
        Try to compile and run it on the broswer. You should see the result in the console.<br>
        <br>
        Nothing special so far. But what if we want to call this function not just at the beginning (when main is executed) but when, for example, you press a button on the webpage?<br>
        This question basically translates to: how do I call C/C++ functions from the JavaScript of my web page?<br>
        <br>
        The easiest way to do this is to use two functions provided by the Emscripten "glue code":
        <ul>
            <li><code class="inline">ccall</code>: calls a compiled C function with the specified variables and return the result.</li>
            <li><code class="inline">cwrap</code>: "wraps" a compiled C function and returns a JavaScript function you can call normally. That is, by far, more useful and we will focus on this method.</li>
        </ul>
        You can call it as follows:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-javascript">var js_wrapped_fib = Module.cwrap("fib", "number", ["number"]);</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        and then you will be able to call the the C compiled fib function just with:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-javascript">var result = js_wrapped_fib(parameter);</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        Let's focus a bit on the parameters we need to pass to crwap:
        <ul>
            <li><span class="italic">name of the function</span>: name of the function in the C source code.</li>
            <li><span class="italic">return type</span>: the return type of the function. This can be <code class="inline">"number"</code>, <code class="inline">"string"</code> or <code class="inline">"array"</code>, which correspond to the appropriate JavaScript types (use number for any C pointer, and <code class="inline">"array"</code> for JavaScript arrays and typed arrays; note that arrays are 8-bit), or for a void function it can be <code class="inline">null</code> (note: the JavaScript null value, not a string containing the word "null").</li>
            <li><span class="italic">list of parameter's types (optional)</span>: within square brackets. An array of the types of arguments for the function (if there are no arguments, this can be omitted). Types are as in return type, except that array is not supported as there is no way for us to know the length of the array.</li>
        </ul>
        <br>
        Another important thing to notice is that Emscripten, during compilation, ignore all the functions that seems unused in order to get a smaller .wasm file. Thus, we need to let it know that we want to keep that functions "alive".<br>
        Again, there are two ways to do this:
        <ul>
            <li>You can add <code class="inline">EMSCRIPTEN_KEEPALIVE</code> to your C functions in the code as shown below:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-c">#include &lt;stdio.h>
#include &lt;emscripten.h> // note we added the emscripten header

int EMSCRIPTEN_KEEPALIVE fib(int n){
    if(n == 0 || n == 1)
        return 1;
    else
        return fib(n-1)+fib(n-2);
}

int main(){
    printf("Hello world!\n");
    int res = fib(5);
    printf("fib(5) = %d\n", res);
    return 0;
}</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->
                    
                In order to test it, compile the C code again, but this time tell the compiler to add cwrap as an extra exported runtime method by using this command:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash">emcc hello.c -o hello.js -s WASM=1 -s EXTRA_EXPORTED_RUNTIME_METHODS='["cwrap"]'</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->
    
                Then edit and run your custom .html file as below:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-html">&lt;script src="hello.js">&lt;/script>
&lt;script>
var js_wrapped_fib = Module.cwrap("fib", "number", ["number"]);

function pressBtn(){
    console.log("The result of fib(5) is:", js_wrapped_fib(5));
}
&lt;/script>

&lt;button onclick="pressBtn()">Click me!&lt;/button>
&lt;p>Open the console to see the result!&lt;/p></code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

                Each time you press the "Click me!" button you should know see a "The result is 8" appearing on your console.
            </li>
            <br>
            <li>
                Alternatively, you can just tell the compiler that you need that functions by using this command (this time you don't need to add to your C code nor the emscripten header, nor <code class="inline" >EMSCRITPEN_KEEPALIVE</code>):

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash">emcc hello.c -o hello.js -s WASM=1 -s EXPORTED_FUNCTIONS='["_fib"]' -s EXTRA_EXPORTED_RUNTIME_METHODS='["cwrap"]'</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

                Note that underscore before the function name, you will always have to add it.<br>
                Test this again (you don't need to modify your custom .html file, just refresh the page).<br>
                You should also notice that the main is no more executed automatically, indeed, it is not even exported. You can add it to the list of exported functions:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash">emcc hello.c -o hello.js -s WASM=1 -s EXPORTED_FUNCTIONS='["_fib", "_main"]' -s EXTRA_EXPORTED_RUNTIME_METHODS='["cwrap"]'</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

                Now your main will be again automatically executed at the beginning and you can also call it from js whenever you want if you wrap it by adding (note that there are no input parameters):

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-javascript">var js_wrapped_main = Module.cwrap("main", "number");</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->
    
            </li>
        </ul>
        <br>
        At this point you may are wondering, how do I pass an array to a WASM function from JavaScript?<br> 
        This will be covered in the section regarding the memory.
        <br><br>
        <div class="important">
            IMPORTANT:<br>
            Exported functions need to be C functions (to avoid <a target="_blank" href="https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_72/rzarg/name_mangling.htm">C++ name mangling</a>). In order to solve that issue you can write in your C++ code:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-c">extern "C"{

int my_func(/* ... */){
    // do stuffs
}

}</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->
                    
        </div>

        <!-- ==================================== CALL JAVASCRIPT FROM C/C++ ==================================== -->
        <h2 id="call_javascript_from_C/C++">Call JavaScript from C/C++</h2>
        
        You can even call JavaScript functions from C code!<br>
        The easiest way to do this is to use the <code class="inline">emscripten_run_script</code> function. Edit your hello.c to:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-c">#include &lt;stdio.h>
#include &lt;emscripten.h>

int main(){
    printf("WASM is running!");
    emscripten_run_script("alert('I have been called from C!')");
    return 0;
}</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        Compile and run it and you should see an alert on the browser as soon as WASM is ready.<br>
        <br>
        You can also call your custom functions and even pass parameters! Edit your call in hello.c to:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-c">emscripten_run_script("set_background_color(1)");</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        and your custom .html to:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-html">&lt;script src="hello.js">&lt;/script>
&lt;script>
function set_background_color(color_idx){
    var color = "red";
    if(color_idx == 1)  	color = "blue";
    else if(color_idx == 2) color = "green";
    
    document.body.style.backgroundColor = color; // set the new background color
}
&lt;/script></code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        You should see a quite horrible change in the background color.<br>
        <br>
        You may noticed that to pass parameters this way is not very easy.<br>
        Luckily, the function <code class="inline">EM_ASM</code> (and its variants) allows you to write JS code, call JS functions, pass parameters and even get return values. Have a look at the following example (you don't need to change anything in the your .html code):<br>

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-c">#include &lt;time.h>   // for time
#include &lt;stdlib.h> // for rand
#include &lt;stdio.h>
#include &lt;emscripten.h>

int main(){
    printf("WASM is running!\n");
    
    srand(time(NULL));      	// initialize random seed
    int color_idx = rand() % 3; // could be 0, 1 or 2
    
    EM_ASM(
        // here you can write inline javascript code!
        console.log("(1) I have been printed from inline JavaScript!");
        console.log("I have no parameters and I do not return anything :(");
        // end of javascript code
    );
        
    // note the underscore and the curly brackets
    EM_ASM_({
        console.log("(2) I have received a parameter! It is:", $0);
        console.log("Setting the background to that color index!");
        set_background_color($0);
    }, color_idx);
        
    // note that you have to specify the return type
    int result = EM_ASM_INT({
        console.log("(3) I received two parameters! They are:", $0, $1);
        console.log("Let's return their sum!");
        return sum($0, $1);
    
        function sum(a, b){
            return a + b;
        }
    }, 13, 10);
    
    printf("(4) The C code received %d as result!\n", result);
    
    return 0;
}</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        As you can see, there are many things you can do with these inline calls. Pretty cool, isn't it?<br>
        <br>
        There is also a way to create a C API in JavaScript, but that requires a bit more work. If you are interested, you can find a good explanation of how to do it <a target="_blank" href="https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#implement-a-c-api-in-javascript">here</a>.

        <!-- ==================================== LIBRARIES ==================================== -->
        <h2 id="libraries">Libraries</h2>
        You may have noticed that we already compiled some libraries with Emscripten. However, these libraries were "standard" libraries. Indeed, Emscripten already provides these libraries ready to be compiled.<br>
        But what if you wanted to compile a non-standard library with Emscripten?<br>
        <br>
        The process is very similar to the one we have already seen to compile the C files.<br>
        In case your library is small and has just some source files (<code class="inline">.c</code> or <code class="inline">.cpp</code>) and some headers file (<code class="inline">.h</code>) you just have to compile your "main" source file and your C code binding them together.<br>
        If you want, you can download the source and the header of this very simple expression <a target="_blank" href="https://github.com/codeplea/tinyexpr">parsing library</a> (found on github):
        <ul>
            <li>header <a href="ref/tinyexpr.h" type="file" download>tinyexpr.h</a> (2 KB),</li>
            <li>source <a href="ref/tinyexpr.c" type="file" download>tinyexpr.c</a> (20 KB).</li>
        </ul>
        Put them in the same folder and create another C file here containing:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-c">#include &lt;stdio.h>
#include "tinyexpr.h"

int main(){
    // te_interp just evaluates the expression in the string and returns a float
    printf("The result of (2+23)/5-1 is: %f\n", te_interp("(2+23)/5-1", 0));
    return 0;
}</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        And then compile binding them together like this:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash">emcc hello.c tinyexpr.c -o hello.html -s WASM=1</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        Now just open the hello.html file and you should see the result.<br>
        Note that you don't need to export any function here because you call <code class="inline">te_interp</code> from the main of your C code and so it is automatically exported.<br>
        If you want, you can wrap <code class="inline">te_interp</code> using <code class="inline">cwrap</code> and then you can call it from directly from JS as we have seen before (note that in this case you have to specify it as an exported function, if you don't use it also in the main).<br>
        But pay attention: the first input parameter of that function is a string (<code class="inline">char*</code>) so you may should read the section about memory before trying to actually use it from JS.<br>
        <br>
        If the project is more complex and contains shared libraries (<code class="inline">.so</code>), static libraries (<code class="inline">.a</code>) or object files (<code class="inline">.o</code> or <code class="inline">.bc</code>) <a target="_blank" href="https://kripken.github.io/emscripten-site/docs/compiling/Building-Projects.html">here</a> you can find a very good explanation on what to do. Remember that you may however need the flag <code class="inline">EXPORTED_FUNCTIONS</code> in order to let the compiler know which functions you want to use.<br>
        For example, that is the command I used to compile the <a target="_blank" href="https://github.com/facebook/zstd">zstd compression library</a> for the <a target="_blank" href="https://marcoselvatici.github.io/ref/shrink/compress/index.html">WASM file compressor</a> I wrote:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash">emcc lib/libzstd.bc -o zstd.js -O2 -s WASM=1 -s EXPORTED_FUNCTIONS="['_ZSTD_compress', '_ZSTD_compressBound', '_ZSTD_isError']" -s EXTRA_EXPORTED_RUNTIME_METHODS="['cwrap']" -s ALLOW_MEMORY_GROWTH=1 -s ABORTING_MALLOC=0</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        <!-- ==================================== MEMORY ==================================== -->
        <h2 id="memory">Memory</h2>
        So far, we have learnt quite a lot about how to use WASM and its features but we never talked about memory.<br>
        As stated in the beginning, WASM works in a protected environment (sandbox) and cannot directly access the memory out of it. The "trick" is that the memory needed for the execution of our C/C++ program, is represented by a <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays">JavaScript typed array</a>.<br>
        When the JavaScript "glue code" is loaded, the array representing the WASM memory is automatically instantiated. Clearly, you can access this object both from JS and from your C/C++ code (as if it was you "normal" memory), and this allows a sort of communication between the two sides.<br>
        <br>
        In order to understand what we are talking about, just run one of the previous examples, open the console and type:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-javascript">Module.HEAP8</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        The result should be something similar to this.
        <img class="center" src="ref/HEAP8.png" width="550"/>
        Indeed, that is an array of bytes that represents your WASM memory. That means you can write your memory byte by byte.<br>
        HEAP8 is just a way you can use to view memory as composed by 8-bit signed integers. That, of course, is not the only view, <a target="_blank" href="https://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#type-accessors-for-the-memory-model">here</a> there is the complete list of what you can use, in case you need something different.<br>
        In other words, even if the array (the C memory) containing the data is exactly the same, we can look at it in different ways in order to work with different data types (you will see an example later).<br>
        <br>
        Why should we bother about this? Well, directly writing the memory is actually the easiest way to pass data structures like arrays and strings (or even the content of a file) to WASM.
        <br>
        Scared of writing directly on raw memory? You don't have to be, just make sure you understand everything you do.<br>
        <br>
        The easiest way to set or get a value from WASM memory is to use two runtime methods you can export during compilation (as we did for cwrap):
        <ul>
            <li><code class="inline">setValue(ptr, value, type)</code></li>
            <li><code class="inline">getValue(ptr, type)</code></li>
        </ul>
        The first argument is the <span class="italic">pointer</span> to the memory location we want to write or read. Note that, since our memory is represented by a JS array, a pointer is just a normal number that represents the offset from the beginning of that array.<br>
        For example, if we call getValue with ptr = 5, we are going to read the fifth position of our memory.<br>
        The <span class="italic">type</span> argument is just the type of the value we want to get or set. The list of alternatives is different from the one we had for cwrap: we are working on a lower level of abstraction. Here we have to use one among <code class="inline">"i8"</code>, <code class="inline">"i16"</code>, <code class="inline">"i32"</code>, <code class="inline">"i64"</code>, <code class="inline">"float"</code>, <code class="inline">"double"</code>, or a pointer type like <code class="inline">"i8*"</code> or just <code class="inline">"*"</code>.<br>
        The <span class="italic">value</span> argument is just the value we want to set (note that this has to be of the type you have selected).<br>
        <br>
        So, let's try to interact with a C function using these two methods.<br>
        First of all, edit your C code to (note that you don't need a main or headers):

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-c">// add one to the value in the input ptr and write this to the content of the output ptr
void addOne(int* input_ptr, int* output_ptr){
	*output_ptr = (*input_ptr) + 1;
}</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        Then compile it with the following command:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-bash">emcc hello.c -o hello.js -s WASM=1 -s EXPORTED_FUNCTIONS='["_addOne"]' -s EXTRA_EXPORTED_RUNTIME_METHODS='["cwrap", "getValue", "setValue"]'</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        Note that there are three runtime methods this time.
        Now edit your custom .html code as below and then run it:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-html">&lt;script src="hello.js">&lt;/script>
&lt;script>
var addOne = Module.cwrap("addOne", null, ["number", "number"]);

function pressBtn(){
	// alloc 4 bytes of memory for the input and 4 for the output (integers)
	var input_ptr = Module._malloc(4);
	var output_ptr = Module._malloc(4);
    
	var value = 6;                                   // value to increment by one
	Module.setValue(input_ptr, value, "i32");        // set the value in WASM memory
	addOne(input_ptr, output_ptr);                   // call the WASM function
	var result = Module.getValue(output_ptr, "i32"); // extract the result from WASM memory
	console.log("The result read is", result, "at position", output_ptr);
    
	// dealloc memory, avoid memory leaks
	Module._free(input_ptr);
	Module._free(output_ptr);
}
&lt;/script>

&lt;button onclick="pressBtn()">Click me!&lt;/button>
&lt;p>Open the console to see the result!&lt;/p></code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        You should see the result in the console.
        Note that <code class="inline">_malloc</code> and <code class="inline">_free</code> does not need to be exported.<br>
        Try to increase the number and notice will get overflow errors if it is bigger than how much is allowed for a 32-bit signed int (you should get overflow at <code class="inline">2^32-1</code>).<br>
        <br>
        Make sure you understand that in this case steps we are following are:
        <ol>
            <li>Alloc two new memory locations in the heap and get pointers to them (<code class="inline">malloc</code>).</li>
            <li>Set the value of the input writing directly to that memory position (<code class="inline">setValue</code>).</li>
            <li>Call the C function to perform our calculation.</li>
            <li>Access the output value stored in the memory (<code class="inline">getValue</code>).</li>
            <li>Free the memory in the heap (<code class="inline">free</code>).</li>    
        </ol>
        <br>
        <div class="important">
            IMPORTANT:<br>
            Even if JavaScript has a garbage collector, C and C++ have not! Therefore, each time we alloc something to the heap with <code class="inline">malloc</code>, we have to remember to dealloc it with <code class="inline">free</code>.
        </div>
        <br>
        Cool! Now you know how to allocate memory at runtime from JS and fill it with data. But what if we wanted to pass an array of values or a string of characters?<br>
        <br>
        Of course you could iterate through all your values and set them one by one with setValue, but that would be very very slow.<br>
        A better option is to write to the memory directly with pure JS functions.<br>
        Say, for example, we have an array of 32-bit signed integers as a JavaScript Int32Array and we want add one to all the elements in that array using a C function. Here is what we should do (pay attention to details, it can be tricky).<br>
        Edit your hello.c to:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-c">// now the pointers represent two array of length = len
void addOne(int* input_ptr, int* output_ptr, int len){
	int i;
	for(i = 0; i < len; i++)
    	output_ptr[i] = input_ptr[i] + 1;
}</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        and compile it as before.
        Edit your custom .html code to:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-html">&lt;script src="hello.js">&lt;/script>
&lt;script>
var addOne = Module.cwrap("addOne", null, ["number", "number", "number"]);

function pressBtn(){
	var input_array = new Int32Array([10, 5, -3, 120, -70]); // array of 32-bit signed int to pass
	var len = input_array.length;					         // 5 elements
	var bytes_per_element = input_array.BYTES_PER_ELEMENT;   // 4 bytes each element
    
	// alloc memory, in this case 5*4 bytes
	var input_ptr = Module._malloc(len * bytes_per_element);
	var output_ptr = Module._malloc(len * bytes_per_element);
    
	Module.HEAP32.set(input_array, input_ptr / bytes_per_element); // write WASM memory calling the set method of the Int32Array, (see below for details)
	addOne(input_ptr, output_ptr, len);   	                       // call the WASM function
	var output_array = new Int32Array(Module.HEAP32.buffer, output_ptr, len); // extract data to another JS array
	console.log("The starting array was:", input_array);
	console.log("The result read is:	", output_array);
    
	// dealloc memory
	Module._free(input_ptr);
	Module._free(output_ptr);
}

&lt;/script>

&lt;button onclick="pressBtn()">Click me!&lt;/button>
&lt;p>Open the console to see the result!&lt;/p></code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        Note that the function <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set">set</a>, is actually a method of the Int32Array object, not something strictly related to WASM. To extract data from memory, instead, we are just using the Int32Array <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array">constructor</a>.<br>
        <br>
        You may have noticed that in the set call we pass a weird offset parameter. Let's think about it.<br>
        When we call <code class="inline">malloc</code>, it returns an offset from the beginning of the WASM memory. This offset could be between 0 and the maximum number of bytes of memory, say n.<br>
        When we do the <code class="inline">set</code> operation, we are viewing our memory as composed of 32-bits integers (4 bytes), so its length is actually n / 4 (but each element is 4 bytes instead of just 1).
        That is why we divide the <code class="inline">input_ptr</code> by <code class="inline">bytes_per_element</code> (that is 4). If we didn't we would get an error like:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-none"># On Firefox
RangeError: invalid or out-of-range index
# On Chrome
Uncaught RangeError: Source is too large</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->
        <br>
        Let's have a look at another example.<br>
        This time, we want to pass a JS string and a character to a C function that counts the number of occurrences and returns it as an integer.<br>
        Change your hello.c to:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-c">int countOccurrences(char* str, int len, char target){
	int i, count = 0;
	for(i = 0; i < len; i++){
    	if(str[i] == target){
        	count++;
    	}
	}
	return count;
}</code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        and compile it. Change your .html file to:

<!-- vvvvvvvvvvv code vvvvvvvvvvv -->
<pre><code class="language-html">&lt;script src="hello.js">&lt;/script>
&lt;script>
var countOccurrences = Module.cwrap("countOccurrences", "number", ["number", "number", "number"]); // note that also the target char is passed as number (char is an unsigned 8-bit integer)

function pressBtn(){
	var str    = "string to examine for this example";
	var target = "e";
	var len    = str.length;
    
	var converted_str    = new Uint8Array(toUTF8Array(str)); // array of bytes (8-bit unsigned int) representing the string
	var converted_target = toUTF8Array(target)[0];           // byte representing the target (8-bit unsigned int)
    
	// alloc memory
	var input_ptr = Module._malloc(len * 1); // 1 byte per element (left just to see)
    
	Module.HEAPU8.set(converted_str, input_ptr); // write WASM memory calling the set method of the Uint8Array
	var occurrences = countOccurrences(input_ptr, len, converted_target); // call the WASM function
	console.log("Occurrences found: ", occurrences);
    
	// dealloc memory
	Module._free(input_ptr);
}

// source: https://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUTF8Array(str) {
	var utf8 = [];
	for (var i=0; i < str.length; i++) {
    	var charcode = str.charCodeAt(i);
    	if (charcode < 0x80) utf8.push(charcode);
    	else if (charcode < 0x800) {
        	utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));
    	}
    	else if (charcode < 0xd800 || charcode >= 0xe000) {
        	utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode>>6) & 0x3f), 0x80 | (charcode & 0x3f));
    	}
    	else {
        	i++;
        	charcode = 0x10000 + (((charcode & 0x3ff)<<10) | (str.charCodeAt(i) & 0x3ff));
        	utf8.push(0xf0 | (charcode >>18), 0x80 | ((charcode>>12) & 0x3f), 0x80 | ((charcode>>6) & 0x3f), 0x80 | (charcode & 0x3f));
    	}
	}
	return utf8;
}
&lt;/script>

&lt;button onclick="pressBtn()">Click me!&lt;/button>
&lt;p>Open the console to see the result!&lt;/p></code></pre>
<!-- ^^^^^^^^^^^ code ^^^^^^^^^^^ -->

        Note that we need a way to encode our string as an array of bytes that can be written to the WASM memory. The function to do so has been taken from StackOverflow and probably there are better ways to do this, consider this if you want to pass strings in your webapp.<br>
        It is interesting that in the C function we read as characters what we passed as numbers, but that is perfectly legal.
        If you are confused, you may want to have a look at the standards for <a target="_blank" href="http://kunststube.net/encoding/">string encoding</a>.<br>
        <br>
        Note also that this time we are viewing the memory as made of 8-bit unsigned int, thus we don't need to divide the pointer when calling set.
        <br>
        <div class="important">
            IMPORTANT:<br>
            In these expamles, we always pass pointers to our data structur allocated in the heap.<br>
            There are ways to pass data sctructures like strings or arrays also using the stack, but there is the disavantage that you cannot grow the stack as like as you want (there is a default limit around 5MB).<br>
            On the other hand, with the heap, you can compile with the flag <code class="inline">-s ALLOW_MEMORY_GROWTH</code> and have much more space, dinamically.
        </div>
        <br>
        <span class="italic">Memory limitations</span><br>
        By default you have a limited amount of memory you can allocate in WASM and this should be around 16MB. You can avoid this by adding the  <code class="inline">-s ALLOW_MEMORY_GROWTH=1</code> at compile time. This will allow you to grow the memory until your browser allows it (this can vary for many reasons, but usually something around 500MB or 1GB).<br>
        Another flag that can be very useful, is  <code class="inline">-s ABORTING_MALLOC=0</code>. This will return  <code class="inline">NULL</code> (0) from your  <code class="inline">Module._malloc</code> call instead of aborting the execution of your code.
        
        <!-- ==================================== CONCLUSIONS ==================================== -->
        <h2 id="Conclusions">Conclusions</h2>
        To sum, in this tutorial we leared:
        <ul>
            <li>What is Webassembly is and how it works.</li>
            <li>How to compile C/C++ programs to Webassembly using Emscripten.</li>
            <li>How to use C/C++ functions and how to call JavaScript from the compiled code.</li>
            <li>How does memory works in Webassembly and how to pass data structures to C/C++ functions.</li>
        </ul>
        Of course, there is more that you can do with this technology, but now you are absolutely able to create amazing Webassembly WebApps.<br>
        I really hope you enjoyed this tutorial and you have started to see the incredible potential of this technology.<br>
        If you want to support me, just leave a like and suggest this tutorial to your coder friends!<br>
        <br>
        Thanks for reading!

        <!-- ==================================== REFERENCES ==================================== -->
        <h2 id="references">References</h2>
        If you want to learn more, here you are the best references I found while doing my Webassembly project:
        <ul>
            <li>Emscripten website (absolutely amazing for details about Emscripten):<br><a target="_blank" href="https://kripken.github.io/emscripten-site">https://kripken.github.io/emscripten-site</a></li>
            <li>MDN Webassembly section (good and detailed explanation of WASM concepts):<br><a target="_blank" href="https://developer.mozilla.org/en-US/docs/WebAssembly">https://developer.mozilla.org/en-US/docs/WebAssembly</a></li>
        </ul>
        There exist also ways to use GUI C libraries like OpenGL so you can create games with 3D graphics that can run quickly on the browser, like <a target="_blank" href="http://webassembly.org/demo/">this</a>. Enjoy! 
        <br>
        <hr>
        <div style="height: 20px;">
            <div style="float: right;">
                written by <a href="http://marcoselvatici.github.io">Marco Selvatici</a>
            </div>
        </div>
        
    </div>

    <script src="prism.js"></script>
</body>