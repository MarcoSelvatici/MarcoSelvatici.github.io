<!DOCTYPE html>
<html>

<head>
	<title>Decompression</title>
	<link rel="stylesheet" type="text/css" href="style.css">
	<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0">
</head>

<body>
	<div id="advancedMenu">
		<div class="menuLine">
			<img src="ref/githubIcon.png" width="30px" height="30px">
			&nbsp; <a  href="https://github.com" target="blank">See code</a>
		</div>
		<div class="menuLine">
			<img src="ref/bugIcon.png" width="30px" height="30px">
			&nbsp; <a  href="https://marcoselvatici.github.io/ref/feedback.html" target="blank">Report a bug</a>
		</div>
		<!--hr style="height:1px; color: rgb(235, 235, 235); background-color:rgb(235, 235, 235)"-->
		<div class="menuLine">
			<img src="ref/authorsIcon.png" width="30px" height="30px">
			&nbsp; Authors
			<div id="authorsDetails">
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&bull; Code: <a href="https://marcoselvatici.github.io/">Marco Selvatici</a><br>
				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&bull; Logo: <a href="null">Luisa Baroncini</a>
			</div>
		</div>
	</div>
	<div id="bodyWrapper">
		<header id="header">
			<div id="logo">
				<img src="ref/logo.png" height="65px">
			</div>
			<div id="headerRight">
				<div id="selectProduct">
					<div class="product" style="float:left;">
						<a href="https://marcoselvatici.github.io/ref/shrink/compress/index.html">Compression</a>
					</div>
					<div class="product" style="float:right; background-color: rgb(235, 235, 235);">
						<a href="https://marcoselvatici.github.io/ref/shrink/decompress/index.html"  style="color: rgb(0, 111, 167)">Decompression</a>
					</div>
				</div>
				<div id="advanced" onclick="open_menu(event)">
					<img src="ref/advancedIcon.png" width="40px" height="40px">
				</div>
			</div>
		</header>
		<div id="mainPart">
			<div id="fileArea">
				<div id="dropArea" ondrop="recieve_dropped_files(event);" ondragover="drag_over(event);" ondragleave="drag_leave(event);">
					<p>Drop here your .zst file(s)</p>
					<p style="font-size: 0.8em; margin-top: 0px;">or</p>
					<label for="fileSelector">
						<img src="ref/searchIcon.png" width="23x" height="23px">
						Browse
					</label>
					<input id="fileSelector" type="file" multiple="multiple">
				</div>
			</div>
			<div id="statsArea">
				<!-- fileStats boxes will be added here via JavaScript -->
			</div>
		</div>
	</div>
	<footer>
		<div id="rightFooter">
			<button id="freeMemoryBtn" disabled title="No memory has been allocated yet">
				<img src="ref/refreshIcon.png" width="28x" height="28px" style="vertical-align: middle">
				Free Memory
			</button>
		</div>
	</footer>


	<!-- DOM SCRIPTS -->
	<script>
	// check if the url has file:// or http(s)://
	// file:// is not going to be able to execute async js for security reasons
	if(location.protocol == "file:")
		setTimeout(display_error, 200, "WASM","Webassembly is may not work if you open the app this way.<br>For security reasons, some browsers are not going to allow<br>asynchronus scripts to be loaded if the file <code>.html</code> is read from<br><code>file://</code>, thus maybe WASM is not going to be loaded.<br><br>You can use <code>python</code> to run an <code>HTTPServer</code> and open the file<br>from <code>localhost:xxxx</code>.");
	
	function close_all_windows() {
		close_error("all");
		close_menu();
	}
	
	function close_menu(){
		document.getElementById("advancedMenu").style.display = "none";
		document.getElementById("advanced").style.backgroundColor = "rgb(0, 111, 167)";
		//document.getElementById("bodyWrapper").style.opacity = "1";

		document.getElementById("bodyWrapper").removeAttribute("onclick");
	}
	
	function open_menu(event){
		event.stopPropagation(); // avoid the propagation of the click
		document.getElementById("advancedMenu").style.display = "inline";
		document.getElementById("advanced").style.backgroundColor = "rgb(0, 143, 214)";
		//document.getElementById("bodyWrapper").style.opacity = "0.5";

		// make all the page clickable to close the menu
		document.getElementById("bodyWrapper").setAttribute("onclick", "close_all_windows()");
	}
	
	// remove the html error code
	function close_error(errorId){
		//console.log(errorId);
		var body = document.body;
		console.log("Closing error: ", errorId);
		// remove all the errors in the page
		if(errorId == 'all'){
			for(var i = body.childNodes.length - 1; i >= 0; i--){
				if(body.childNodes[i].id != undefined)
					if(body.childNodes[i].id.slice(0, 6) == "error_")
						body.removeChild(body.childNodes[i]);
				else
					// ideally, all the errors are at the very end of the body, so if it is no more an error, then break
					break;
			}
			// no more errors, can remove the onclick attribute from bodywrapper
			document.getElementById("bodyWrapper").removeAttribute("onclick");
			document.getElementById("bodyWrapper").style.opacity = "1";
		}
		// remove only the element you selected by clicking x
		else{
			var count_errors = 0;
			for(var i = body.childNodes.length - 1; i >= 0; i--){
				if(body.childNodes[i].id != undefined){
					if(body.childNodes[i].id.slice(0, 6) == "error_")
						count_errors += 1;
					if(body.childNodes[i].id == errorId){
						body.removeChild(body.childNodes[i]);
						count_errors -= 1;
					}
				}
				else
					// ideally, all the errors are at the very end of the body, so if it is no more an error, then break
					break;
			}
			if(count_errors == 0){ // no more errors, can remove the onclick attribute from bodywrapper
				document.getElementById("bodyWrapper").removeAttribute("onclick");
				document.getElementById("bodyWrapper").style.opacity = "1";
			}
		}
	}

	// displays errors
	function display_error(file_name, description){
		var error = document.createElement("DIV");
		error.setAttribute("id", "error_"+file_name);
		error.setAttribute("class", "errorMessage");
		var errorId = "error_" + file_name;
		var call = 'close_error("' + errorId + '")';
		error.innerHTML = "<span onclick='"+call+"'>x</span><h1>Error handling "+file_name+":</h1><p>"+description+"<br><br>Press <code>F12</code> to open console and see details.</p>";
		document.body.appendChild(error);
		
		// make all the page clickable to close all the errors
		document.getElementById("bodyWrapper").setAttribute("onclick", "close_all_windows()");
		document.getElementById("bodyWrapper").style.opacity = "0.5";
	}

	// make the button clickable
	function allow_free_memory_button(){
		var btn = document.getElementById("freeMemoryBtn");
		btn.disabled = false;
		btn.title = "Free memory used by this app";
	}
	
	/* file boxes scripts */
	// create the initial box for the file
	// gives to the icons and labels a unique ID containing the file_name
	function create_fileStats_box(file_name){
		var statsArea = document.getElementById('statsArea');
		statsArea.insertAdjacentHTML('afterbegin',
			'<div class="fileStats" id="'+file_name+'">' + file_name + '<div class="columns"><div class="leftColumn"><p class="loadLabel"><img id="loadIcon_'+file_name+'" src="ref/waitIcon.png" height="23px", width="23px">&nbsp; Loading</p><p class="compressLabel"><img id="compressIcon_'+file_name+'" src="ref/waitIcon.png" height="23px", width="23px">&nbsp; Decompressing</p></div><div class="rightColumn"><p id="sizeLabel_'+file_name+'">Size: [waiting]</p><p id="timeLabel_'+file_name+'">Time: [waiting]</p></div></div></div>'
		);
	}

	// updates the two icons for load and compress
	function update_fileStats_box_icon(file_name, action, success){
		var iconId = action + "Icon_" + file_name;
		var icon = document.getElementById(iconId);
		if(success)
			icon.setAttribute('src', 'ref/successIcon.png');
		else{
			icon.setAttribute('src', 'ref/failIcon.png');
			if(action == "load"){ // if loading fails, then also compression fails
				update_fileStats_box_icon(file_name, "compress", false);
			}
		}
	}

	function update_fileStats_box_time(file_name, time){
		var timeLabelId = "timeLabel_" + file_name;
		var timeLabel = document.getElementById(timeLabelId);
		if(time > 1000)
			timeLabel.innerHTML = 'Time: ' + (time/1000).toFixed(3) + " s";
		else
			timeLabel.innerHTML = 'Time: ' + time.toFixed(0) + " ms";
	}
	
	function update_fileStats_box_size(file_name, original_size, final_size){
		var sizeLabelId = "sizeLabel_" + file_name;
		var sizeLabel = document.getElementById(sizeLabelId);
		sizeLabel.innerHTML = getSizeStr(original_size) + ' &rarr; ' + getSizeStr(final_size);
	}

	// return a string to the size with memory unit
	function getSizeStr(size){
		if(size > (1024*1024*1024))
			return (Math.round( size/(1024*1024*1024) * 10 ) / 10) + " GB";
		if(size > (1024*1024))
			return (Math.round( size/(1024*1024) * 10 ) / 10) + " MB";
		if(size > 1024)
			return (Math.round( size/(1024) * 10 ) / 10) + " KB";
		return (Math.round( size * 10 ) / 10) + " B";
	}

	/* drop file scripts */
	// recieve files from dropArea and pass them to the file_handler
	function recieve_dropped_files(event){
		allow_free_memory_button();
		drag_leave(event); 			// restore opacity
		event.preventDefault(); 	// prevent default behavoiur on drop file (opening it or download it)
		var data = event.dataTransfer;
		// Use DataTransfer interface to access the file(s)
		/*console.log("Dropping file(s):");
		for (var i=0; i < data.files.length; i++) {
				console.log("... file[" + i + "].name = " + data.files[i].name);
		}*/
		handle_files(data.files);
	}

	function drag_over(event){
		event.preventDefault();
		document.getElementById("dropArea").style.opacity = "0.5";
	}

	function drag_leave(event){
		event.preventDefault();
		document.getElementById("dropArea").style.opacity = "1";
	}
	</script>
		

	<!-- WASM SCRIPTS -->

	<!-- Include the JavaScript glue code. -->
	<!-- This will load the WebAssembly module and run its main. --> 
	<script src="zstd.js"></script>

	<script>
	// wrapping C functions to call them from js
	var ZSTD_findDecompressedSize = cwrap("ZSTD_findDecompressedSize", "number", ["number", "number"]);
	var ZSTD_decompress = cwrap("ZSTD_decompress", "number", ["number", "number", "number", "number"]);
	var ZSTD_isError = cwrap("ZSTD_isError", "number", ["number"]);
	</script>

	<script>
	// input -> bytes of the file (Uint8Array), name of the file
	// creates and downloads a file with that data
	function download_binary_file(bynary_data,  file_name){
		// creating blob
		var mimetype = "application/octet-stream";
		var blob = new Blob([bynary_data], {type: mimetype});
		var url = window.URL.createObjectURL(blob);
		
		// download 
		var element = document.createElement('a');
		element.setAttribute('href', url);
		element.setAttribute('download', (file_name));
		element.style.display = 'none';
		document.body.appendChild(element);
		element.click();
		document.body.removeChild(element);
		window.URL.revokeObjectURL(url);
	}

	// tries to allocate the space required in WASM heap
	function malloc_or_die(size_of_data, file_name){
		const data_ptr = Module._malloc(size_of_data);
		if(data_ptr == 0){	// error allocating memory
			update_fileStats_box_icon(file_name, "compress", false); // update icon with fail
			display_error(file_name, "failed allocation of " + size_of_data + " bytes.<br> The file could be too big or have a wrong format.");
			throw new Error("Failed allocation of " + size_of_data + " bytes.");
		}
		return data_ptr;
	}

	// tries to decompress the data
	function decompress_or_die(decompressed_data_ptr, estimate_original_size, compressed_data_ptr, size_of_data, file_name){
		const original_size = ZSTD_decompress(decompressed_data_ptr,
												estimate_original_size,
												compressed_data_ptr,
												size_of_data);
		
		if(ZSTD_isError(original_size)){ // error decompressing data
			update_fileStats_box_icon(file_name, "compress", false); // update icon with fail
			display_error(file_name, "Failed decompression.");
			throw new Error("Failed decompression");
		}
		update_fileStats_box_icon(file_name, "compress", true);		// update icon with success	
		return original_size;
	}

	// input -> compressed file
	// 1. read the file
	// 2. perform decompression
	// 3. download the new file
	function read_and_decompress(file){
		var TIME_start = performance.now();			// measure performaces

		var reader = new FileReader();				// FileReader object
		var file_name = file.name;
		reader.readAsArrayBuffer(file);				// perform reading

		reader.onerror = (function(){				// fail reading
			update_fileStats_box_icon(file_name, "load", false); // update icon with fail
			display_error(file_name, "Error reading the file, make sure it is not a folder.");
		});

		reader.onload = (function(){				// when reading is finished
			update_fileStats_box_icon(file_name, "load", true); // update icon with success
			var TIME_after_file_reading = performance.now();
			
			console.log("File reading finished");

			var compressed_data = new Uint8Array(reader.result, 0, reader.result.byteLength); // getting bytes in as a Uint8Array
			var TIME_after_copying_data_to_array = performance.now();
			const size_of_data = compressed_data.length;										// size of my data

			console.log("Passing the data to wasm");

			// I only have 5Mb of stack
			// instead of passing the array to ZSTD_compress I am copying it into the heap and then pass a pointer to it
			const compressed_data_ptr = malloc_or_die(size_of_data, file_name);
			// writing the data directly in wasm memory, so I will use everything from the heap
			Module.HEAPU8.set(compressed_data, compressed_data_ptr);
			
			var TIME_after_copying_data_to_heap = performance.now();
			
			// calls to wasm for compression
			const estimate_original_size = ZSTD_findDecompressedSize(compressed_data_ptr, size_of_data);
			const decompressed_data_ptr = malloc_or_die(estimate_original_size, file_name);			// allocate that space
			const original_size = decompress_or_die(decompressed_data_ptr,
												estimate_original_size,
												compressed_data_ptr,
												size_of_data,
												file_name);

			var TIME_after_decompression = performance.now();
			
			console.log("Decompression:", size_of_data, "-->", original_size);
			update_fileStats_box_size(file_name, size_of_data, original_size); 									// update the size
			update_fileStats_box_time(file_name, TIME_after_decompression - TIME_after_copying_data_to_heap);	// update time

			// compressed_data_ptr is a pointer to my compressed data in wasm memory
			// getting data out of wasm memory
			var decompressed_data = new Uint8Array(Module.HEAPU8.buffer, decompressed_data_ptr, original_size);
			
			var TIME_after_extract_data_from_heap = performance.now();

			// removing .zst from the name
			download_binary_file(decompressed_data, file_name.substring(0, file_name.length - 4));
			
			var TIME_after_download = performance.now();
			
			// clear the heap to avoid memory leaks
			Module._free(decompressed_data_ptr);
			Module._free(compressed_data_ptr);

			// print performance data
			console.log("1. Reading the file:           ", TIME_after_file_reading - TIME_start);
			console.log("2. Copying data to Uint8Array: ", TIME_after_copying_data_to_array - TIME_after_file_reading);
			console.log("3. Copying data to Heap:       ", TIME_after_copying_data_to_heap - TIME_after_copying_data_to_array);
			console.log("4. Decompression:              ", TIME_after_decompression - TIME_after_copying_data_to_heap);
			console.log("5. Extract data from Heap:     ", TIME_after_extract_data_from_heap - TIME_after_decompression);
			console.log("6. Download file:              ", TIME_after_download - TIME_after_extract_data_from_heap);
		});
	}

	// handles all files
	function handle_files(files){
		for(var i = 0; i < files.length; i++){
			console.log("recieved ", files[i].name.length);
			console.log(files[i].name.substring(files[i].name.length - 4, files[i].name.length));
			if(files[i].name.length <= 5 || files[i].name.substring(files[i].name.length - 4, files[i].name.length) != ".zst"){
				display_error(files[i].name, "the file does not end with <code>.zst</code>, ignored.");
				continue;
			}
			allow_free_memory_button();
			create_fileStats_box(files[i].name); // create the box under the drop area
			read_and_decompress(files[i]);
		}
	}

		// recieve files from select button
	function recieve_selected_files(event){
		handle_files(event.target.files);
	}

	// add the event listener
	document.getElementById("fileSelector").addEventListener("change", recieve_selected_files);

	// add event listener to refresh the page
	document.getElementById("freeMemoryBtn").addEventListener("click", function(){location.reload();});
	</script>

	<!-- errors boxes will be added here via JavaScript -->
</body>

</html>
